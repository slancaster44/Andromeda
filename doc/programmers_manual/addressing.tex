\subsection{Addressing Modes}\label{subsec:addressing-modes}

\subsubsection{Immediate (IMM)}
\par The 8-bit operand field will be sign-extended to 16-bits.
It will then immediately be used as the secondary operand for the instruction.
\begin{verbatim}
        org(0x0000)
    def entry:
        lda.imm     -12
        hlt
\end{verbatim}`
The code above would result in `-12' being loaded into the accumulator.
Note: The 16-bit two's complement form of -12 is $1111111111110100_{2}$

\subsubsection{Memory Direct (DIR)}
\par The constant $FF00_{16}$ will be added to the 8-bit operand field.
This will yield a 16-bit value in the range $FF00_{16}$ - $FFFF_{16}$ inclusive.
This value will then be used as an address.
The value stored at that address will be used as the secondary operand for the instruction.
\begin{verbatim}
        org(0x0000)
    def entry:
        sta.dir     0x01
        hlt
\end{verbatim}
The code above would store the accumulator into the address $FF01_{16}$.

\subsubsection{Relative Direct (REL)}\label{subsec:relative-direct-(rel)}
\par The 8-bit operand field is sign-extended to 16-bits.
That value is added to the program counter (PC) to yield and address.
The contents of that address will be used as the secondary operand for the instruction.
\begin{verbatim}
        org(0x0000)
    def entry:
        lda.rel     2
        hlt
    def data:
        dw(-11)
\end{verbatim}
The code above would be result in -11 being loaded into the Accumulator.
The `lda' instruction exists at address $0000_{16}$, adding `2' to this address results in the value $0002_{16}$.
The value stored at $0002_{16}$ (`-11') is loaded into the Accumulator.

\subsubsection{Memory Indirect (IND)}
The constant $FF00_{16}$ will be added to the 8-bit operand field.
This will yield a 16-bit value in the range $FF00_{16}$ - $FFFF_{16}$ inclusive.
This value will then be used as an address.
The value stored at that address will be used as another address known as the pointer.
This value stored at this final pointer address will be used as the secondary operand for the instruction.,
\begin{verbatim}
        org(0x0000)
    def entry:
        lda.ind pointer
        hlt

        org(0xFF01)
    def pointer:
        0xD000

        org(0xD000)
    def final_value:
        -12
\end{verbatim}
The code above will result in -12 being loaded into the accumulator.
The value stored in address $FF01_{16}$ ($D000_{16}$) was used as an address to find the final value (-12).

\subsubsection{Memory Indirect \& Auto Increment (INC)}
This addressing mode behaves similarly to memory indirect addressing.
The secondary operand is obtained in the same manner.
However, after the value is obtained, the pointer will be incremented.
\begin{verbatim}
        org(0x0000)
    def entry:
        lda.inc pointer
        hlt

        org(0xFF01)
    def pointer:
        0xD000

        org(0xD000)
    def final_value:
        -12
\end{verbatim}
The code above will result in -12 being loaded into the accumulator.
However, after the instruction has completed execution, pointer will be incremented to $D001_{16}$

\subsubsection{Auto Decrement \& Memory Indirect (DEC)}
This addressing mode behaves similarly to memory indirect addressing.
Before the instruction is executed, the pointer will be decremented.
Then the secondary operand is obtained in the same manner as it is in simple Memory Indirect addressing.
\begin{verbatim}
        org(0x0000)
    def entry:
        lda.dec pointer
        hlt

        org(0xFF01)
    def pointer:
        0xD000

        org(0xCFFF)
    def final_value:
        13
        -12
\end{verbatim}
The code above will result in 13 being loaded into the accumulator.
Pointer will have been decremented to $CFFF_{16}$ so the `13' could be addressed indirectly